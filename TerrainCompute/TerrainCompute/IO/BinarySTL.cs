using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using ngeometry.VectorGeometry;

namespace TerrainComputeC.IO
{
	//[LicenseProvider(typeof(Class46))]
	public class BinarySTL
	{
		public BinarySTL()
		{
            //System.ComponentModel.LicenseManager.Validate(typeof(BinarySTL));
			this.Triangles = new List<Triangle>();
			this.Colors = new List<BinarySTL.STLColor>();
			this.ColorDefinition = BinarySTL.STLColor.ColorDefinition.BGR;
			//base..ctor();
		}

		private bool method_0(Triangle triangle_0)
		{
			return triangle_0.Vertex1.X < 0.0 || triangle_0.Vertex1.Y < 0.0 || triangle_0.Vertex1.Z < 0.0 || triangle_0.Vertex2.X < 0.0 || triangle_0.Vertex2.Y < 0.0 || triangle_0.Vertex2.Z < 0.0 || triangle_0.Vertex3.X < 0.0 || triangle_0.Vertex3.Y < 0.0 || triangle_0.Vertex3.Z < 0.0;
		}

		private bool method_1(Triangle triangle_0, Vector3d vector3d_0)
		{
			bool result;
			try
			{
				Global.SuspendEpsilon(1E-06, 1E-06);
				if (triangle_0.NormalVector.Normalize() == vector3d_0.Normalize())
				{
					Global.ResumeEpsilon();
					result = false;
				}
				else
				{
					Global.ResumeEpsilon();
					result = true;
				}
			}
			catch
			{
				Global.ResumeEpsilon();
				result = true;
			}
			return result;
		}

		public void Read(string fileName)
		{
			using (BinaryReader binaryReader = new BinaryReader(File.Open(fileName, FileMode.Open)))
			{
				BinarySTL.Class0 @class = new BinarySTL.Class0(binaryReader.ReadChars(80));
				if (@class.string_0.ToUpper().Contains("COLOR="))
				{
					this.ContainsColorDefinitions = true;
				}
				binaryReader.ReadUInt32();
				bool flag = true;
				while (flag)
				{
					try
					{
						float num = binaryReader.ReadSingle();
						float num2 = binaryReader.ReadSingle();
						float num3 = binaryReader.ReadSingle();
						float num4 = binaryReader.ReadSingle();
						float num5 = binaryReader.ReadSingle();
						float num6 = binaryReader.ReadSingle();
						float num7 = binaryReader.ReadSingle();
						float num8 = binaryReader.ReadSingle();
						float num9 = binaryReader.ReadSingle();
						float num10 = binaryReader.ReadSingle();
						float num11 = binaryReader.ReadSingle();
						float num12 = binaryReader.ReadSingle();
						ushort num13 = binaryReader.ReadUInt16();
						if (num13 > 0)
						{
							this.ContainsColorDefinitions = true;
						}
						try
						{
							Vector3d vector3d_ = new Vector3d((double)num, (double)num2, (double)num3);
							Triangle triangle = new Triangle(new Point((double)num4, (double)num5, (double)num6), new Point((double)num7, (double)num8, (double)num9), new Point((double)num10, (double)num11, (double)num12), false);
							if (this.method_0(triangle))
							{
								this.HasNegativeCoordinates = true;
							}
							if (this.method_1(triangle, vector3d_))
							{
								this.HasInconsitentNormals = true;
							}
							this.Triangles.Add(triangle);
							this.Colors.Add(new BinarySTL.STLColor(num13, this.ColorDefinition));
							this.NumberOfTrianglesRead++;
						}
						catch
						{
							this.NumberOfDegenerateTriangles++;
						}
					}
					catch
					{
						flag = false;
					}
				}
			}
		}

		public void Write(string fileName)
		{
			string string_ = "Binary STL generated by TCPlugin for AutoCAD www.computational-cad.com".PadRight(80);
			BinarySTL.Class0 @class = new BinarySTL.Class0(string_);
			uint count = (uint)this.Triangles.Count;
			using (BinaryWriter binaryWriter = new BinaryWriter(File.Open(fileName, FileMode.Create)))
			{
				binaryWriter.Write(@class.char_0);
				binaryWriter.Write(count);
				for (int i = 0; i < this.Triangles.Count; i++)
				{
					try
					{
						Triangle triangle = this.Triangles[i];
						Vector3d vector3d = triangle.NormalVector.Normalize();
						binaryWriter.Write((float)vector3d.X);
						binaryWriter.Write((float)vector3d.Y);
						binaryWriter.Write((float)vector3d.Z);
						binaryWriter.Write((float)triangle.Vertex1.X);
						binaryWriter.Write((float)triangle.Vertex1.Y);
						binaryWriter.Write((float)triangle.Vertex1.Z);
						binaryWriter.Write((float)triangle.Vertex2.X);
						binaryWriter.Write((float)triangle.Vertex2.Y);
						binaryWriter.Write((float)triangle.Vertex2.Z);
						binaryWriter.Write((float)triangle.Vertex3.X);
						binaryWriter.Write((float)triangle.Vertex3.Y);
						binaryWriter.Write((float)triangle.Vertex3.Z);
						byte[] array = this.Colors[i].ToBytes();
						binaryWriter.Write(array[0]);
						binaryWriter.Write(array[1]);
						this.NumberOfTrianglesWritten++;
					}
					catch
					{
						this.NumberOfDegenerateTriangles++;
					}
				}
			}
		}

		public BinarySTL.STLColor.ColorDefinition ColorDefinition;

		public List<BinarySTL.STLColor> Colors;

		public bool ContainsColorDefinitions;

		public bool HasInconsitentNormals;

		public bool HasNegativeCoordinates;

		public int NumberOfDegenerateTriangles;

		public int NumberOfTrianglesRead;

		public int NumberOfTrianglesWritten;

		public List<Triangle> Triangles;

		//[LicenseProvider(typeof(Class46))]
		internal class Class0
		{
			internal Class0(char[] char_1)
			{
                //System.ComponentModel.LicenseManager.Validate(typeof(BinarySTL.Class0));
				this.string_0 = "";
				this.char_0 = new char[80];
				//base..ctor();
				if (char_1.Length != 80)
				{
					throw new ArgumentException("Header length not 80 bytes in binary STL.");
				}
				this.char_0 = char_1;
				for (int i = 0; i < 80; i++)
				{
					this.string_0 += char_1[i].ToString();
				}
			}

			internal Class0(string string_1)
			{
                //System.ComponentModel.LicenseManager.Validate(typeof(BinarySTL.Class0));
				this.string_0 = "";
				this.char_0 = new char[80];
				//base..ctor();
				char[] array = string_1.ToCharArray();
				if (array.Length != 80)
				{
					throw new ArgumentException("Header length not 80 bytes in binary STL.");
				}
				this.string_0 = string_1;
				this.char_0 = array;
			}

			internal char[] char_0;

			internal string string_0;
		}

		//[LicenseProvider(typeof(Class46))]
		public class STLColor
		{
			public STLColor()
			{
                //System.ComponentModel.LicenseManager.Validate(typeof(BinarySTL.STLColor));
				this.A = 255;
				this.IsValid = true;
				this._cDef = BinarySTL.STLColor.ColorDefinition.BGR;
				//base..ctor();
			}

			public STLColor(ushort colorAttribute, BinarySTL.STLColor.ColorDefinition colorDefinition)
			{
                //System.ComponentModel.LicenseManager.Validate(typeof(BinarySTL.STLColor));
				this.A = 255;
				this.IsValid = true;
				this._cDef = BinarySTL.STLColor.ColorDefinition.BGR;
				//base..ctor();
				BitArray bitArray = new BitArray(new int[]
				{
					(int)colorAttribute
				});
				BitArray bitArray2 = new BitArray(new bool[]
				{
					default(bool),
					default(bool),
					default(bool),
					bitArray[0],
					bitArray[1],
					bitArray[2],
					bitArray[3],
					bitArray[4]
				});
				BitArray bitArray3 = new BitArray(new bool[]
				{
					default(bool),
					default(bool),
					default(bool),
					bitArray[5],
					bitArray[6],
					bitArray[7],
					bitArray[8],
					bitArray[9]
				});
				BitArray bitArray4 = new BitArray(new bool[]
				{
					default(bool),
					default(bool),
					default(bool),
					bitArray[10],
					bitArray[11],
					bitArray[12],
					bitArray[13],
					bitArray[14]
				});
				BitArray bitArray5 = new BitArray(new bool[]
				{
					bitArray[15]
				});
				byte[] array = new byte[1];
				switch (this._cDef)
				{
				case BinarySTL.STLColor.ColorDefinition.RGB:
					bitArray2.CopyTo(array, 0);
					this.R = array[0];
					bitArray3.CopyTo(array, 0);
					this.G = array[0];
					bitArray4.CopyTo(array, 0);
					this.B = array[0];
					this.IsValid = bitArray5[0];
					return;
				case BinarySTL.STLColor.ColorDefinition.BGR:
					bitArray4.CopyTo(array, 0);
					this.R = array[0];
					bitArray3.CopyTo(array, 0);
					this.G = array[0];
					bitArray2.CopyTo(array, 0);
					this.B = array[0];
					this.IsValid = !bitArray5[0];
					return;
				default:
					return;
				}
			}

			public byte[] ToBytes()
			{
				BitArray bitArray = new BitArray(new byte[]
				{
					this.R
				});
				BitArray bitArray2 = new BitArray(new byte[]
				{
					this.G
				});
				BitArray bitArray3 = new BitArray(new byte[]
				{
					this.B
				});
				BitArray bitArray4 = null;
				switch (this._cDef)
				{
				case BinarySTL.STLColor.ColorDefinition.RGB:
					bitArray4 = new BitArray(new bool[]
					{
						bitArray[0],
						bitArray[1],
						bitArray[2],
						bitArray[3],
						bitArray[4],
						bitArray2[0],
						bitArray2[1],
						bitArray2[2],
						bitArray2[3],
						bitArray2[4],
						bitArray3[0],
						bitArray3[1],
						bitArray3[2],
						bitArray3[3],
						bitArray3[4],
						this.IsValid
					});
					break;
				case BinarySTL.STLColor.ColorDefinition.BGR:
					bitArray4 = new BitArray(new bool[]
					{
						bitArray3[0],
						bitArray3[1],
						bitArray3[2],
						bitArray3[3],
						bitArray3[4],
						bitArray2[0],
						bitArray2[1],
						bitArray2[2],
						bitArray2[3],
						bitArray2[4],
						bitArray[0],
						bitArray[1],
						bitArray[2],
						bitArray[3],
						bitArray[4],
						this.IsValid
					});
					break;
				}
				byte[] array = new byte[2];
				bitArray4.CopyTo(array, 0);
				return array;
			}

			public override string ToString()
			{
				return string.Concat(new string[]
				{
					"R: ",
					this.R.ToString(),
					" G: ",
					this.G.ToString(),
					" B: ",
					this.B.ToString(),
					" A: ",
					this.A.ToString(),
					" Valid: ",
					this.IsValid.ToString()
				});
			}

			public byte A;

			public byte B;

			public byte G;

			public bool IsValid;

			public byte R;

			public BinarySTL.STLColor.ColorDefinition _cDef;

			////[LicenseProvider(typeof(Class46))]
			public enum ColorDefinition
			{
				RGB,
				BGR
			}
		}
	}
}
